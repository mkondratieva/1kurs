#include<stdio.h> //удалить из массива числа, для кот. есть близкие им
//удаляются все копии
#include<stdlib.h>
#include<time.h>
int cmp(int, int);
int cmp(int a, int b){  //а близко b
	if(abs(a-b)<=1)
		return 1; 
	return 0;
}
int main(void){ 
	int a[11],n=11,
	left,right,n_new=n;
	srand(time(NULL));   //   -+-+-+-+I??????N_NEW----N 
	for(int i=0;i<n;i++){a[i]=rand()%11; printf("%d ",a[i]);}
//в качестве nullval используем -1, для произвольного массива это значение нужно будет  искать
	for(int i=0;i<n_new;i++){  //ИЩЕМ И УДАЛЯЕМ ЭЛ-ТЫ a[right],right>i, близкие. A]I]
//элементы массива, индексы r которых <i уже обработаны (если a[k]=-1, то его нужно будет удалить из массива, иначе a[k] не является близким никакому элементу исходного массива
		for(left=i+1,right=i+1;right<n_new;right++)//правым бегунком перебираем элементы массива, которые еще не удалены (для a[k], k> n_new ранее нашли близкий элемент массива, поэтому такие a[k] можно не проверять
			if(!cmp(a[right],a[i])){//если a[i], a[right] не близкие, меняем местами a[right] c  a[left]. Нельзя просто пометить скопировать a[right] в a[left], т.к. будет потеряно значение a[left], а оно может потребоваться для поска близких к a[j],j>i
				int tmp=a[right];a[right]=a[left];a[left++]=tmp;//сохраняем, не затирая удаляемые, т.к. они нужны для дальнейших проверок, массив сепарируется так, что  междеу left и right  находятся элементы, блтзкие a[i]
			}
		n_new=left;//новый размер после обработки a[i] (за исключением обработкии самого a[i])
		for(int j=n_new;j<n;j++)//проверка, нужно ли удалять a[i] (сравниваем его с теми, которые уже удалены)
			if(cmp(a[i],a[j])){
				a[i]=-1;break;
		}	}
	for(left=0,right=0; right<n_new;right++) //2 бегунка, удаляем помеченные элементы
		if(a[right]>=0) a[left++]=a[right];
	n_new=left;
	puts("\nres");
	for(int i=0;i<n_new;i++)printf("%d ",a[i]);
	puts("\n");

	return 0;
} 